name: CD Pipeline

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types: [completed]
    branches: [main, develop]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: github.ref == 'refs/heads/develop' && github.event.workflow_run.conclusion == 'success'
    environment:
      name: staging
      url: https://staging.example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --name ${{ vars.EKS_CLUSTER_NAME_STAGING }}

      - name: Deploy to staging
        id: deploy_staging
        run: |
          # Deploy application
          envsubst < k8s/staging/deployment.yaml | kubectl apply -f -

          # Wait for rollout
          echo "Waiting for deployment rollout..."
          if ! kubectl rollout status deployment/payment-platform -n staging --timeout=300s; then
            echo "Deployment rollout failed"
            kubectl rollout undo deployment/payment-platform -n staging
            exit 1
          fi

          # Verify pod health
          echo "Verifying pod health..."
          if ! kubectl wait --for=condition=ready pod -l app=payment-platform -n staging --timeout=300s; then
            echo "Pod health check failed"
            kubectl rollout undo deployment/payment-platform -n staging
            exit 1
          fi

          # Check load balancer health
          echo "Checking load balancer health..."
          LB_HOSTNAME=""
          for i in {1..30}; do
            LB_HOSTNAME=$(kubectl get svc payment-platform -n staging -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
            if [ ! -z "$LB_HOSTNAME" ]; then
              echo "Load balancer hostname: $LB_HOSTNAME"
              break
            fi
            echo "Waiting for load balancer... (attempt $i/30)"
            sleep 10
          done

          if [ -z "$LB_HOSTNAME" ]; then
            echo "Load balancer health check failed - no hostname assigned"
            kubectl rollout undo deployment/payment-platform -n staging
            exit 1
          fi

          # Verify load balancer endpoint health
          echo "Verifying load balancer endpoint health..."
          for i in {1..20}; do
            if curl -sf "http://$LB_HOSTNAME/health" > /dev/null 2>&1; then
              echo "Load balancer endpoint is healthy"
              break
            fi
            if [ $i -eq 20 ]; then
              echo "Load balancer endpoint health check failed"
              kubectl rollout undo deployment/payment-platform -n staging
              exit 1
            fi
            echo "Waiting for load balancer endpoint... (attempt $i/20)"
            sleep 15
          done

          # Verify application health
          echo "Verifying application health..."
          if ! ./scripts/verify-deployment.sh staging ${{ github.sha }}; then
            echo "Application health verification failed"
            kubectl rollout undo deployment/payment-platform -n staging
            exit 1
          fi
        env:
          IMAGE_TAG: ${{ github.sha }}

      - name: Run smoke tests
        run: |
          kubectl wait --for=condition=ready pod -l app=payment-platform -n staging --timeout=300s
          if ! ./scripts/smoke-tests.sh staging; then
            echo "Smoke tests failed - initiating rollback"
            kubectl rollout undo deployment/payment-platform -n staging
            exit 1
          fi

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 45
    if: github.ref == 'refs/heads/main' && github.event.workflow_run.conclusion == 'success'
    environment:
      name: production
      url: https://app.example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --name ${{ vars.EKS_CLUSTER_NAME_PROD }}

      - name: Pre-deployment validation
        run: |
          ./scripts/pre-deployment-checks.sh production

      - name: Blue-Green deployment
        run: |
          # Deploy green environment
          echo "Deploying green environment..."
          envsubst < k8s/production/deployment-green.yaml | kubectl apply -f -
          
          # Wait for deployment and monitor
          echo "Waiting for green deployment to be ready..."
          if ! kubectl rollout status deployment/payment-platform-green -n production --timeout=600s; then
            echo "Green deployment failed. Rolling back..."
            kubectl rollout undo deployment/payment-platform-green -n production
            exit 1
          fi
          
          # Run smoke tests
          echo "Running smoke tests..."
          if ! ./scripts/smoke-tests.sh production-green; then
            echo "Smoke tests failed. Rolling back..."
            kubectl rollout undo deployment/payment-platform-green -n production
            exit 1
          fi
          
          # Switch traffic
          echo "Switching traffic to green deployment..."
          kubectl patch service payment-platform -n production -p '{"spec":{"selector":{"version":"green"}}}'
          
          # Monitor for 5 minutes
          echo "Monitoring deployment for 5 minutes..."
          ./scripts/monitor-deployment.sh 300 || {
            echo "Deployment monitoring failed. Rolling back..."
            kubectl patch service payment-platform -n production -p '{"spec":{"selector":{"version":"blue"}}}'
            kubectl rollout undo deployment/payment-platform-green -n production
            exit 1
          }
          
          # Scale down blue deployment
          echo "Scaling down blue deployment..."
          kubectl scale deployment payment-platform-blue --replicas=1 -n production

      - name: Create release
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ github.run_number }}
          name: Production Release v${{ github.run_number }}
          body: |
            ## Production Deployment Summary
            
            ### Deployment Information
            - **Commit**: ${{ github.sha }}
            - **Branch**: ${{ github.ref_name }}
            - **Timestamp**: ${{ github.event.workflow_run.updated_at }}
            
            ### Validations
            - ✅ Constitutional compliance
            - ✅ Security validation
            - ✅ Smoke tests
            - ✅ Load balancer health
            - ✅ Application health
            
            ### Monitoring
            - [View Metrics Dashboard](https://metrics.example.com/prod/dashboard)
            - [View Logs](https://logs.example.com/prod/latest)
            
            ### Support
            If you encounter any issues, please contact the DevOps team immediately.
          draft: false
          prerelease: false

  notify-staging:
    needs: [deploy-staging]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Staging Deployment Status
        if: ${{ secrets.SLACK_BOT_TOKEN != '' }}
        uses: slackapi/slack-github-action@v1.24.0
        with:
          channel-id: 'deployments'
          slack-message: |
            *Staging Deployment* ${{ needs.deploy-staging.result == 'success' && ':white_check_mark:' || ':x:' }}

            *Environment:* Staging
            *Status:* ${{ needs.deploy-staging.result == 'success' && 'Success' || 'Failed' }}
            *Branch:* ${{ github.ref_name }}
            *Commit:* ${{ github.sha }}
            *Triggered by:* ${{ github.actor }}

            <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Details>
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

      - name: Create Staging Deployment Record
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: "${{ github.sha }}",
              environment: "staging",
              auto_merge: false,
              required_contexts: []
            });

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: "${{ needs.deploy-staging.result == 'success' && 'success' || 'failure' }}",
              environment_url: "https://staging.example.com",
              log_url: "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
              description: "Staging deployment ${{ needs.deploy-staging.result == 'success' && 'completed successfully' || 'failed' }}"
            });

  notify-deployment:
    needs: [deploy-production]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Deployment Status
        if: ${{ secrets.SLACK_BOT_TOKEN != '' }}
        uses: slackapi/slack-github-action@v1.24.0
        with:
          channel-id: 'deployments'
          slack-message: |
            *Production Deployment* ${{ needs.deploy-production.result == 'success' && ':rocket:' || ':x:' }}

            *Environment:* Production
            *Status:* ${{ needs.deploy-production.result == 'success' && ':white_check_mark: Success' || ':x: Failure' }}
            *Version:* v${{ github.run_number }}
            *Commit:* ${{ github.sha }}
            *Triggered by:* ${{ github.actor }}

            ${{ needs.deploy-production.result == 'failure' && ':warning: *Automatic rollback initiated*' || '' }}

            <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Deployment Details>
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

      - name: Update Status Page
        if: always()
        run: |
          curl -X POST "https://api.statuspage.io/v1/pages/${{ secrets.STATUSPAGE_PAGE_ID }}/components/${{ secrets.STATUSPAGE_COMPONENT_ID }}" \
            -H "Authorization: OAuth ${{ secrets.STATUSPAGE_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{
              "component": {
                "status": "${{ needs.deploy-production.result == 'success' && 'operational' || 'major_outage' }}"
              }
            }'

      - name: Create Deployment Record
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: "${{ github.sha }}",
              environment: "production",
              auto_merge: false,
              required_contexts: []
            });
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: "${{ needs.deploy-production.result == 'success' && 'success' || 'failure' }}",
              environment_url: "https://app.example.com",
              log_url: "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
              description: "Deployment ${{ needs.deploy-production.result == 'success' && 'completed successfully' || 'failed' }}"
            });